Sapir-Whorf hypothesis: your ability to think a thought depends on knowing the words capable of expressing the thought.  If you don't know the words, you can't express the thought and may not even be able to formulate it.
- makes sense that programmers get better the longer they spend in a language.
- better if the new language is similar or shares a conceptual root with one they know.

Avoid arbitrary variations - taxes the brain - code consistency.

Where we are on the technology wave impacts our productivity and code-quality.

Program "into" a language. First, determine the thoughts we want to express, and then figure out how to do that in the target language.  Perfectly reasonable to extend a language to get the features of a more robust one. 

Recognize design as an explicit activity.

Design as a "wicked problem." Problem solving it twice. Sometimes unavoidable, but you're not going to know if a problem is wicked until after the fact.

It's cheaper to make mistakes in the design _process_. But not afterward.

Software's Primary Technical Imperative: managing complexity

Essential Complexity vs. Accidental Complexity
- decreasing essential complexity gives better returns
- managing the essential and accidental difficulties is the core of software development.
- the root of these difficulties is complexity
- software projects can fail for many reasons, but if that reason is technical, it's often for uncontrolled complexity.

|Essential|Accidental|
| ------ | ------ |
|properties that define what something is|properties that the thing just has|
|complexity is caused by the problem to be solved|complexity is problems engineers cause and can fix|

**Example: Car**

|Essential|Accidental|
| ------ | ------ |
|doors|gull-wing|
|engine|V8|
|wheels|mag wheels|

Dijkstra: no one's skill is big enough to contain a modern computer program

Minimize the amount of essential complexity anyone has to deal with

Keep accidental complexity from needlessly proliferating.
- automation helps here

### Desirable Characteristics of Design
1. Minimal Complexity
2. Ease of maintenance
3. Loose coupling
4. Extensibility
5. Reusability
6. High fan-in
7. Low to medium fan-out
8. Portability
9. Leanness
10. Stratification
11. Standard techniques

Lines between systems as water hoses.  Taking a system out or changing it?  How wet are we gonna get?
- communication between systems should be "need to know"



- still transcribing

